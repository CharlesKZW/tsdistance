

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lockstep &mdash; tsdistance 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> tsdistance
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../ElasticMeasures.html">Elastic Measures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LockstepMeasures.html">Lockstep Measures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SlidingMeasures.html">Sliding Measures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../KernelMeasures.html">Kernel Measures</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">tsdistance</a>
        
      </nav>


      <div class="wy-nav-content">
<div class="git-ribbon">
  <a href="http://github.com/SwissDataScienceCenter" rel="me">Join us on GitHub</a>
</div>

        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>lockstep</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for lockstep</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>



<div class="viewcode-block" id="minkowski"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.minkowski">[docs]</a><span class="k">def</span> <span class="nf">minkowski</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The formula for minkowski function is: :math:`\begin{equation*}(\sum_{i=1}^n |X_i - Y_i|^p)^{\frac{1}{p}}\end{equation*}`</span>
<span class="sd">    </span>
<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :param p: parameter for :math:`p` in the formula above</span>
<span class="sd">    :type p: float</span>
<span class="sd">    :return: the Minkowski distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="n">p</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">sum</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">);</span></div>

<div class="viewcode-block" id="abs_euclidean"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.abs_euclidean">[docs]</a><span class="k">def</span> <span class="nf">abs_euclidean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Euclidean distance is our most intuitive way of defining distance as that&#39;s how we define it in our physical world.</span>
<span class="sd">    The formula is: :math:`\sqrt{\sum_{i=1}^n(X_i - Y_i)^2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Euclidean distance</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">sum</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span></div>


<div class="viewcode-block" id="manhattan"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.manhattan">[docs]</a><span class="k">def</span> <span class="nf">manhattan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manhattan distance is when :math:`p = 1`. </span>
<span class="sd">    Manhattan distance is often called city-block distance as in the 2-dimensional case it is often represented using city-blocks. </span>
<span class="sd">    Manhattan distance&#39;s advantage is that outliers skew the result less than in Chebyshev or Euclidean distance.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n |X_i - Y_i|`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Manhattan distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span><span class="o">+=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="chebyshev"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.chebyshev">[docs]</a><span class="k">def</span> <span class="nf">chebyshev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    {Chebyshev distance} is represented as the limit as p tends towards infinity. </span>
<span class="sd">    Chebyshev distance is computed as: :math:`max_i(X_i - Y_i) = \lim_{p \rightarrow \infty} (\sum_{i=1}^n |X_i - Y_i|^p)^{\frac{1}{p}}`</span>
<span class="sd">    </span>
<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Chebyshev distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="nb">max</span> <span class="o">&lt;</span> <span class="n">dif</span><span class="p">:</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="n">dif</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">;</span></div>


<div class="viewcode-block" id="sorensen"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.sorensen">[docs]</a><span class="k">def</span> <span class="nf">sorensen</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorensen distance is the :math:`L_1` distance but divided by the sum of the two time series. </span>
<span class="sd">    Because of this, the range of the Sorensen distance is :math:`[0,1]`. </span>
<span class="sd">    It is often used in ecology and environmental sciences.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^n |X_i - Y_i|}{\sum_{i=1}^n(X_i + Y_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Sorensen distance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">sumb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">suma</span><span class="o">/</span><span class="n">sumb</span><span class="p">;</span></div>

<div class="viewcode-block" id="gower"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.gower">[docs]</a><span class="k">def</span> <span class="nf">gower</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gower distance is the average distance between the elements. </span>
<span class="sd">    It is often used for mixed qualitative and quantitative data.</span>
<span class="sd">    The formula is: :math:`\frac{1}{n} * \sum_{i=1}^n |X_i - Y_i|`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Gower distance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span>  <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="soergel"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.soergel">[docs]</a><span class="k">def</span> <span class="nf">soergel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Soergel distance is the :math:`L_1` distance divided by the sum of the maximum of each element pair.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^n |X_i - Y_i|}{\sum_{i=1}^n max(X_i,Y_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Soergel distance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">sumb</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="k">return</span> <span class="n">suma</span><span class="o">/</span><span class="n">sumb</span><span class="p">;</span></div>

<div class="viewcode-block" id="Kulczynski"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.Kulczynski">[docs]</a><span class="k">def</span> <span class="nf">Kulczynski</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Kulczynski distance is very similar but the :math:`L_1` distance is divided by the sum of the minimum of each element pair.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^n|X_i - Y_i|}{\sum_{i=1}^n min(X_i,Y_i)}`.</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Kulczynski distance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">sumb</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">if</span> <span class="n">sumb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">suma</span><span class="o">/</span><span class="n">sumb</span><span class="p">;</span></div>

<div class="viewcode-block" id="canberra"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.canberra">[docs]</a><span class="k">def</span> <span class="nf">canberra</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Canberra distance is the :math:`L_1` distance but each element difference is divided by the element sum. </span>
<span class="sd">    Canberra distance is often used for data scattered about an origin.</span>
<span class="sd">    The formula is: :math:`\sum \frac{|X_i - Y_i|}{X_i + Y_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Canberra distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="lorentzian"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.lorentzian">[docs]</a><span class="k">def</span> <span class="nf">lorentzian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lorentzian distance is the natural log of the :math:`L_1` distance between to time series.</span>
<span class="sd">    To avoid :math:`ln(0)` and guarantee non-negative distances 1 is added.</span>
<span class="sd">    The formula is: :math:`sum_{i=1}^n ln(1 + |X_i - Y_i|)`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Lorentzian distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="Intersection"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.Intersection">[docs]</a><span class="k">def</span> <span class="nf">Intersection</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intersection distance is the :math:`L_1` distance divided by 2.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^n |X_i - Y_i|)}{2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Intersection distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="wave_hedges"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.wave_hedges">[docs]</a><span class="k">def</span> <span class="nf">wave_hedges</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wave Hedges distance is the length of the time series subtracted by the sum of the ratio of the minimum and maximum of each element pair.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n1 - \frac{min(X_i,Y_i)}{max(X_i,Y_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Wave Hedges distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="nb">max</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
        
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span></div>


<div class="viewcode-block" id="czekanowski"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.czekanowski">[docs]</a><span class="k">def</span> <span class="nf">czekanowski</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Czekanowski distance is the intersection equivalent of Sorensen. </span>
<span class="sd">    It is the sum of the minimums of each element pair divided by the sum of the elements multiplied by 2.</span>
<span class="sd">    The formula is: :math:`2\frac{\sum_{i=1}^nmin(X_i,Y_i)}{\sum_{i=1}^nX_i + Y_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Czekanowski distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">sum_add</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sum_dif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">sum_add</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">sum_dif</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">if</span> <span class="n">sum_add</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">sum_dif</span><span class="o">/</span><span class="n">sum_add</span><span class="p">;</span></div>

<div class="viewcode-block" id="motyka"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.motyka">[docs]</a><span class="k">def</span> <span class="nf">motyka</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Motyka distance is the sum of the minimums of each element pair divided by the sum of the elements of each time series.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^nmin(X_i,Y_i)}{\sum_{i=1}^nX_i + Y_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Motyka distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">sumb</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">suma</span><span class="o">/</span><span class="n">sumb</span><span class="p">;</span></div>

<div class="viewcode-block" id="tanimoto"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.tanimoto">[docs]</a><span class="k">def</span> <span class="nf">tanimoto</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tanimoto distance is equivalent to the Soergel distance measure. </span>
<span class="sd">    It is the difference between the maximum and minimum of each element pair divided by the maximums of each element pair.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}max(X_i,Y_i) - min(X_i,Y_i)}{\sum_{i=1}^nmax(X_i,Y_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Tanimoto distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">minxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
    <span class="n">sumxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">sumxy</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">minxy</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">([</span><span class="n">sumxy</span> <span class="o">-</span> <span class="n">minxy</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">));</span></div>

<div class="viewcode-block" id="innerproduct"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.innerproduct">[docs]</a><span class="k">def</span> <span class="nf">innerproduct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inner Product distance is the dot product between two time series.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n (X_iY_i)`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Inner Product distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="harmonicmean"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.harmonicmean">[docs]</a><span class="k">def</span> <span class="nf">harmonicmean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Harmonic Mean distance is the sum of the element-wise harmonic means between the time series. </span>
<span class="sd">    It is often used when discussing rates of change.</span>
<span class="sd">    The formula is: :math:`2\sum_{i=1}^n (\frac{X_iY_i}{X_i + Y_i})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Harmonic Mean distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)]);</span>

    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span></div>

<div class="viewcode-block" id="kumarhassebrook"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.kumarhassebrook">[docs]</a><span class="k">def</span> <span class="nf">kumarhassebrook</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kumar-Hassebrook distance is like harmonic mean distance but the denominator is reduced by the product of the elements.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^nX_iY_i}{\sum_{i=1}^n(X_i + Y_i) - \sum_{i=1}^n X_iY_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Kumar-Hassebrook distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span> <span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">))),</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)))</span></div>

<div class="viewcode-block" id="jaccard"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.jaccard">[docs]</a><span class="k">def</span> <span class="nf">jaccard</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jaccard distance is a metric and the complement of the Jaccard similarity coefficient.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^n(X_i - Y_i)^2}{\sum_{i=1}^n (X^2 + y^2) - \sum_{i=1}^n (X_iY_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Jaccard distance     </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span></div>

<div class="viewcode-block" id="cosine"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.cosine">[docs]</a><span class="k">def</span> <span class="nf">cosine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cosine distance is the complement of the cosine similarity that measures the angle between two vectors.</span>
<span class="sd">    As compared to the Inner Product distance, Cosine distance does not take the time series magnitude into account.</span>
<span class="sd">    The formula is: :math:`1 - \frac{\sum_{i=1}^n X_iY_i}{\sqrt{\sum_{i=1}^nX_i^2}\sqrt{\sum{i=1}^nY_i^2}}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Cosine distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sumy</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">sumy</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">sumx</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="n">sumx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">sumy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="nb">sum</span><span class="o">/</span> <span class="p">((</span><span class="n">sumx</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">sumy</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))));</span></div>

<div class="viewcode-block" id="dice"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.dice">[docs]</a><span class="k">def</span> <span class="nf">dice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dice distance is the complement of the Dice similarity. </span>
<span class="sd">    It is not a metric but it is widely used in biological taxonomy.</span>
<span class="sd">    The formula is: :math:`1 - \frac{2\sum_{i=1}^nX_iY_i}{\sum_{i=1}^nX^2 + y^2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Dice distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">sum_dif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sum_add</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">sum_dif</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">sum_add</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sum_add</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sum_dif</span><span class="o">/</span><span class="n">sum_add</span><span class="p">;</span></div>

<div class="viewcode-block" id="fidelity"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.fidelity">[docs]</a><span class="k">def</span> <span class="nf">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fidelity distance is the sum of the square root of the element-wise product of elements from two time series. </span>
<span class="sd">    The formula is: :math:`\sum_{i = 1}^n \sqrt{X_iY_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Fidelity distance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="bhattacharyya"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.bhattacharyya">[docs]</a><span class="k">def</span> <span class="nf">bhattacharyya</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bhattacharyya distance is a statistal distance metric that measures the similarity of two probability distributions. </span>
<span class="sd">    It is the general case of Mahalanobis distance.</span>
<span class="sd">    The formula is: :math:`-ln(\sum_{i=1}^n\sqrt{X_iY_i})`</span>
<span class="sd">    </span>
<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Bhattacharyya distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">return</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">sum</span><span class="p">);</span></div>

<div class="viewcode-block" id="Square_chord"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.Square_chord">[docs]</a><span class="k">def</span> <span class="nf">Square_chord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Squared Chord distance is the sum of the square of the differences of the square roots of each element. </span>
<span class="sd">    This exaggerates more dissimilar features.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n(\sqrt{X_i}-\sqrt{Y_i})^2`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Squared Chord distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="hellinger"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.hellinger">[docs]</a><span class="k">def</span> <span class="nf">hellinger</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hellinger Distance is Matusita distanced scaled by :math:`\sqrt{2}`.</span>
<span class="sd">    The formula is: :math:`\sqrt{2\sum_{i=1}^n(\sqrt{X_i}-\sqrt{Y_i})^2}`.</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Hellinger Distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">-=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">sum</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span></div>

<div class="viewcode-block" id="matusita"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.matusita">[docs]</a><span class="k">def</span> <span class="nf">matusita</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matusita Distance is the square root of the squared chord distance.</span>
<span class="sd">    The formula is: :math:`\sqrt{\sum_{i=1}^n(\sqrt{X_i}-\sqrt{Y_i})^2}`.</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Matusita Distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">result</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span></div>

<div class="viewcode-block" id="squared_euclidean"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.squared_euclidean">[docs]</a><span class="k">def</span> <span class="nf">squared_euclidean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Squared Euclidean distance is the square of the Euclidean distance.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n (X_i - Y_i)^2`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Squared Euclidean distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span><span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="clark"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.clark">[docs]</a><span class="k">def</span> <span class="nf">clark</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clark distance is the square root of the sum of the squared ratio of the difference and sum of the element pairs.</span>
<span class="sd">    The formula is: :math:`\sqrt{\sum_{i=1}^n(\frac{|X_i - Y_i|}{X_i + Y_i})^2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Clark distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">sum</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span></div>

<div class="viewcode-block" id="neyman"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.neyman">[docs]</a><span class="k">def</span> <span class="nf">neyman</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Neyman Chi Squared distance is the sum of squared difference of the element pairs divided by the element in the first time series.</span>
<span class="sd">    The formula is :math:`\sum_{i=1}^n(\frac{(X_i - Y_i)^2}{X_i})`.</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Neyman Chi Squared distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="pearson"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.pearson">[docs]</a><span class="k">def</span> <span class="nf">pearson</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pearson Chi Squared distance is the sum of squared difference of the element pairs divided by the element in the second time series. </span>
<span class="sd">    Notably, :math:`Pearson(X,Y)` is equal to :math:`Neyman(Y,X)`. </span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n(\frac{(X_i - Y_i)^2}{Y_i})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Pearson Chi Squared distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="squared_chi"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.squared_chi">[docs]</a><span class="k">def</span> <span class="nf">squared_chi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Squared Chi distance is the sum of the squared difference of the element pairs divided by the sum of the element pairs. </span>
<span class="sd">    This can be considered a symmetric version of the Neyman Chi Squared distance.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n(\frac{(X_i - Y_i)^2}{X_i + Y_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Pearson Squared Chi distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<span class="k">def</span> <span class="nf">K_divergence</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divergence distance is the sum of the squared difference of the element pairs over the squared sum multplied by 2. </span>
<span class="sd">    Divergence distance is not a metric.</span>
<span class="sd">    The formula is: :math:`2\sum_{i=1}^n\frac{(X_i - Y_i)^2}{(X_i + Y_i)^2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Divergence distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)))));</span>


<div class="viewcode-block" id="additive_symm_chi"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.additive_symm_chi">[docs]</a><span class="k">def</span> <span class="nf">additive_symm_chi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Additive Symmetric Chi distance is the sum of the square of the difference of the element pairs multiplied by the sum of the element pairs divided by the product of the element pairs.</span>
<span class="sd">    The formula is: :math:`2\sum_{i=1}^n\frac{(X_i - Y_i)^2(X_i + Y_i)}{X_iY_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Divergence distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="prob_symmetric_chi"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.prob_symmetric_chi">[docs]</a><span class="k">def</span> <span class="nf">prob_symmetric_chi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Probabilistic Symmetric Chi distance is Squared Chi distance multiplied by 2.</span>
<span class="sd">    The formula is: :math:`2\sum_{i=1}^n\frac{(X_i - Y_i)^2}{X_i + Y_i}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Probabilistic Symmetric Chi distance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="kullback"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.kullback">[docs]</a><span class="k">def</span> <span class="nf">kullback</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kullback-Leibler distance is known as KL divergence or information deviation. </span>
<span class="sd">    It is a measure of how different two probability distributions are to each other.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^nX_iln(\frac{2X_i}{X_i + Y_i})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Kullback-Leibler distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span><span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="jeffrey"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.jeffrey">[docs]</a><span class="k">def</span> <span class="nf">jeffrey</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jeffreys distance is considered to be the symmetric version of Kullback-Leibler distance. </span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n(X_i-Y_i)ln(\frac{X_i}{Y_i})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Jeffreys distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))));</span></div>

<div class="viewcode-block" id="K_divergence"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.K_divergence">[docs]</a><span class="k">def</span> <span class="nf">K_divergence</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divergence distance is the sum of the squared difference of the element pairs over the squared sum multplied by 2. </span>
<span class="sd">    Divergence distance is not a metric.</span>
<span class="sd">    The formula is: :math:`2\sum_{i=1}^n\frac{(X_i - Y_i)^2}{(X_i + Y_i)^2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Divergence distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)))));</span></div>


<div class="viewcode-block" id="topsoe"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.topsoe">[docs]</a><span class="k">def</span> <span class="nf">topsoe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Topsoe distance is a symmetric version of K divergence distance.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^nX_iln(\frac{2X_i}{X_i + Y_i}) + Y_iln(\frac{2Y_i}{Y_i + X_i})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Topsoe distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">logxy</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">logxy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">logxy</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">logxy</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="jensen_shannon"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.jensen_shannon">[docs]</a><span class="k">def</span> <span class="nf">jensen_shannon</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jensen-Shannon distance is Topsoe distance divided by 2.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^nX_iln(\frac{2X_i}{X_i + Y_i}) + Y_iln(\frac{2Y_i}{Y_i + X_i})}{2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Jensen-Shannon distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">logxy</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">logxy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">logxy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">logxy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="mf">.5</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="jensen_difference"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.jensen_difference">[docs]</a><span class="k">def</span> <span class="nf">jensen_difference</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The formula for Jensen Difference Distance is: :math:`\sum_{i=1}^n \frac{X_iln(X_i) + Y_iln(Y_i)}{2} - \frac{X_i + Y_i}{2} * ln(\frac{X_i + Y_i}{2})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Jensen Difference Distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyavg</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">xyavg</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">xyavg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xyavg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>



<div class="viewcode-block" id="vicis_wave_hedges"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.vicis_wave_hedges">[docs]</a><span class="k">def</span> <span class="nf">vicis_wave_hedges</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vicis-Wave Hedges distance is a variant of the Wave Hedges function and can be considered a :math:`L_1` function.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n \frac{X_i - Y_i}{min(X_i,Y_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Vicis-Wave Hedges distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="nb">min</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="emanon2"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.emanon2">[docs]</a><span class="k">def</span> <span class="nf">emanon2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Emamon 2 distance is a variant of Vicis Wave Hedges where the squared differences and minimums are added together.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n \frac{(X_i - Y_i)^2}{min(X_i,Y_i)^2}`</span>
<span class="sd">    </span>
<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Emamon 2 distance </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">mind</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="n">mind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">mind</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="emanon3"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.emanon3">[docs]</a><span class="k">def</span> <span class="nf">emanon3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Emamon 3 distance is another variant of Vicis Wave Hedges where only the differences are squared.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n \frac{(X_i - Y_i)^2}{min(X_i,Y_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Emamon 3 distance </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>

<div class="viewcode-block" id="emanon4"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.emanon4">[docs]</a><span class="k">def</span> <span class="nf">emanon4</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Emamon 4 distance is the last Emamon measure. It is the sum of the squared difference over the maximum of the element pairs.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n \frac{(X_i - Y_i)^2}{max(X_i,Y_i)}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Emamon 4 distance </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">maxd</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">maxd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">maxd</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="max_symmetric_chi"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.max_symmetric_chi">[docs]</a><span class="k">def</span> <span class="nf">max_symmetric_chi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Max-Symmetric Chi distance takes the maximum of the Pearson and Neyman distances.</span>
<span class="sd">    The formula is: :math:`max(\sum_{i=1}^n\frac{(X_i - Y_i)^2}{X_i},\sum_{i=1}^n\frac{(X_i - Y_i)^2}{Y_i})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Max-Symmetric Chi distance </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">xy</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">sumb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">((</span><span class="n">suma</span><span class="p">,</span><span class="n">sumb</span><span class="p">));</span></div>

<div class="viewcode-block" id="min_symmetric_chi"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.min_symmetric_chi">[docs]</a><span class="k">def</span> <span class="nf">min_symmetric_chi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Min-Symmetric Chi takes the minimum of the Perason and Neyman distances.</span>
<span class="sd">    The formula is: :math:`min(\sum_{i=1}^n\frac{(X_i - Y_i)^2}{X_i},\sum_{i=1}^n\frac{(X_i-Y_i)^2}{Y_i})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Min-Symmetric Chi distance </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">xy</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">sumb</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">((</span><span class="n">suma</span><span class="p">,</span><span class="n">sumb</span><span class="p">));</span></div>


<div class="viewcode-block" id="taneja"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.taneja">[docs]</a><span class="k">def</span> <span class="nf">taneja</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Taneja distance utilizes both the arithmetic and geometric mean.</span>
<span class="sd">    The formula is: :math:`\sum_{i=1}^n\frac{(X_i + Y_i)}{2} * ln(\frac{X_i + Y_i}{2\sqrt{X_iY_i}})`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Taneja distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">xy</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">xy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="kumar_johnson"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.kumar_johnson">[docs]</a><span class="k">def</span> <span class="nf">kumar_johnson</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The formula for Kumar-Johnson distance is: :math:`\sum_{i=1}^n\frac{(X_i^2 - Y_i^2)^2}{2(X_iY_i)^{\frac{1}{2}}}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Kumar-Johnson distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span></div>


<div class="viewcode-block" id="avg_l1_linf"><a class="viewcode-back" href="../LockstepMeasures.html#lockstep.avg_l1_linf">[docs]</a><span class="k">def</span> <span class="nf">avg_l1_linf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Avg(:math:`L_1`,:math:`L_\infty`) is the average between the :math:`L_1` distance and Chebyshev distance.</span>
<span class="sd">    The formula is: :math:`\frac{\sum_{i=1}^n(|X_i - Y_i|) + max(X_i - Y_i)}{2}`</span>

<span class="sd">    :param x: a time series </span>
<span class="sd">    :type x: np.array</span>
<span class="sd">    :param y: another time series</span>
<span class="sd">    :type y: np.array</span>
<span class="sd">    :return: the Avg(:math:`L_1`,:math:`L_\infty`}) distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">dif</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dif</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">):</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="n">dif</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="nb">max</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span></div>



<span class="k">def</span> <span class="nf">ED</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>


    <span class="k">if</span> <span class="nb">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">sum</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>







<span class="k">def</span> <span class="nf">jansen_shannon</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">logxy</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">logxy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>

    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">logxy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">logxy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="mf">.5</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">;</span>







<span class="k">def</span> <span class="nf">kulczynski</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">suma</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">sumb</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">if</span> <span class="n">sumb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">suma</span><span class="o">/</span><span class="n">sumb</span><span class="p">;</span>





<span class="k">def</span> <span class="nf">PairWiseScalingDistance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">sumx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sumxy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">sumx</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">sumxy</span> <span class="o">+=</span> <span class="n">xy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">sumxy</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">sumx</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>


<span class="k">def</span> <span class="nf">square_chord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span>





</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, John Paparrizos, Charlie Kaize Wu, and Marc Johnson.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>